Build & deploy “Site Surgeon v0.1” (Node/Express API)

Goal
- POST /api/audit { url, email, name? } → run Lighthouse (mobile) + extra SEO checks, produce report.html + report.pdf + JSON, and webhook results to GHL.
- Serve reports at /reports/{id}/report.html and /reports/{id}/report.pdf
- Return JSON with links and “3 Critical Fixes”.

Create a new Repl
- Name: sitesurgeon-api
- Language: Node.js (ESM)

Dependencies
npm i express cors express-rate-limit jsdom node-fetch@3
npm i lighthouse chrome-launcher puppeteer
npm i html-minifier-terser dayjs uuid

Project structure
/root
  server.mjs
  lib/
    lighthouse.mjs
    extraChecks.mjs
    scoring.mjs
    render.mjs
    webhook.mjs
  templates/
    report.html
  reports/   (static output)
  .env.example
  package.json

ENV (add in Replit Secrets)
GHL_WEBHOOK_URL=<your GHL incoming webhook URL>
BASE_URL=<your live Replit URL once deployed, e.g. https://sitesurgeon-api.replit.app>
BRAND_NAME=HugemouthSEO
GOOGLE_PSI_API_KEY= (optional fallback; leave blank if not using)

package.json (scripts)
{
  "type": "module",
  "scripts": {
    "start": "node server.mjs"
  }
}

server.mjs
--------------------------------
import express from "express";
import cors from "cors";
import rateLimit from "express-rate-limit";
import { auditUrl } from "./lib/lighthouse.mjs";
import { runExtraChecks } from "./lib/extraChecks.mjs";
import { scoreAndFixes } from "./lib/scoring.mjs";
import { renderAndSave } from "./lib/render.mjs";
import { sendToGHL } from "./lib/webhook.mjs";
import { v4 as uuidv4 } from "uuid";
import dayjs from "dayjs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.use(cors());
app.use(express.json({ limit: "1mb" }));
app.use("/reports", express.static(path.join(__dirname, "reports")));

const limiter = rateLimit({ windowMs: 60 * 1000, max: 6 });
app.use("/api/", limiter);

app.get("/health", (_, res) => res.json({ ok: true }));

app.post("/api/audit", async (req, res) => {
  try {
    const { url, email, name } = req.body || {};
    if (!url || !email) return res.status(400).json({ error: "url and email required" });

    const id = uuidv4();
    const lh = await auditUrl(url);                 // Lighthouse JSON
    const extra = await runExtraChecks(url);        // on-page, directives, E-E-A-T, local
    const scored = scoreAndFixes(lh, extra);        // overall score + topFixes[]

    const out = await renderAndSave({
      id, url, lh, extra, scored,
      brand: process.env.BRAND_NAME || "HugemouthSEO",
      baseUrl: process.env.BASE_URL
    });

    // Fire GHL webhook (non-blocking)
    sendToGHL({
      event: "site_audit_completed",
      timestamp: dayjs().toISOString(),
      contact: { email, name, source: "SiteSurgeon" },
      site: { url: out.finalUrl || url, statusCode: 200 },
      scores: scored.scores,
      top_fixes: scored.topFixes,
      links: {
        report_html: out.reportHtmlUrl,
        report_pdf: out.reportPdfUrl,
        screenshot_mobile: out.screenshotUrl
      }
    }).catch(()=>{});

    return res.json({
      id, url,
      overallScore: scored.scores.overall,
      topFixes: scored.topFixes,
      reportUrlHTML: out.reportHtmlUrl,
      reportUrlPDF: out.reportPdfUrl,
      screenshotUrl: out.screenshotUrl
    });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: "audit_failed" });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log("SiteSurgeon API listening on " + PORT));
--------------------------------

lib/lighthouse.mjs
--------------------------------
import lighthouse from "lighthouse";
import chromeLauncher from "chrome-launcher";

export async function auditUrl(url) {
  try {
    const chrome = await chromeLauncher.launch({ chromeFlags: ["--headless", "--no-sandbox"] });
    const result = await lighthouse(url, {
      port: chrome.port,
      output: "json",
      formFactor: "mobile",
      screenEmulation: { mobile: true, width: 360, height: 640, deviceScaleFactor: 2, disabled: false }
    }, { onlyCategories: ["performance","seo","best-practices","accessibility"] });
    await chrome.kill();
    return JSON.parse(result.report);
  } catch (err) {
    // Optional: fallback to PSI API if key present
    const key = process.env.GOOGLE_PSI_API_KEY;
    if (!key) throw err;
    const r = await fetch(`https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${encodeURIComponent(url)}&category=PERFORMANCE&category=SEO&category=BEST_PRACTICES&strategy=MOBILE&key=${key}`);
    return await r.json();
  }
}
--------------------------------

lib/extraChecks.mjs
--------------------------------
import { JSDOM } from "jsdom";

export async function runExtraChecks(url) {
  const res = await fetch(url, { redirect: "follow" });
  const html = await res.text();
  const dom = new JSDOM(html);
  const d = dom.window.document;

  const get = (sel) => d.querySelector(sel);
  const title = (get("title")?.textContent || "").trim();
  const metaDesc = get('meta[name="description"]')?.getAttribute("content") || "";
  const h1s = [...d.querySelectorAll("h1")];
  const canonical = get('link[rel="canonical"]')?.href || "";
  const og = !!get('meta[property^="og:"]');
  const twitter = !!get('meta[name^="twitter:"]');
  const viewport = !!get('meta[name="viewport"]');
  const imgs = [...d.querySelectorAll("img")];
  const altPct = imgs.length ? Math.round(100 * imgs.filter(i => i.getAttribute("alt"))?.length / imgs.length) : 100;
  const hasAuthor = !!(d.querySelector('[rel="author"], .author, .byline'));
  const hasAbout = !!d.querySelector('a[href*="about"]');
  const hasContact = !!d.querySelector('a[href*="contact"]');
  const napText = /(\(\d{3}\)\s*\d{3}-\d{4}|\d{3}[-.\s]\d{3}[-.\s]\d{4})/i.test(d.body.textContent || "");

  // quick reachability checks
  const robots = await fetch(new URL("/robots.txt", url)).then(r=>r.ok).catch(()=>false);
  const sitemap = await fetch(new URL("/sitemap.xml", url)).then(r=>r.ok).catch(()=>false);

  return {
    onPage: { title, metaDesc, h1Count: h1s.length, canonical, og, twitter, viewport, altPct },
    directives: { robots, sitemap },
    eeat: { hasAuthor, hasAbout, hasContact },
    local: { napText }
  };
}
--------------------------------

lib/scoring.mjs
--------------------------------
export function scoreAndFixes(lh, extra) {
  // Pull Lighthouse-like scores (0-100). Handle PSI fallback shape if needed.
  const cat = lh.categories || {};
  const perf = Math.round(((cat.performance?.score || 0) * 100));
  const seo = Math.round(((cat.seo?.score || 0) * 100));
  const bp  = Math.round(((cat["best-practices"]?.score || 0) * 100));
  const acc = Math.round(((cat.accessibility?.score || 0) * 100));

  // Core Web Vitals — use audit details if available
  const audits = lh.audits || {};
  const LCP = audits["largest-contentful-paint"]?.numericValue || 0;   // ms
  const INP = audits["interactive"]?.numericValue || audits["experimental-interaction-to-next-paint"]?.numericValue || 0;
  const CLS = audits["cumulative-layout-shift"]?.numericValue || 0;

  let cwv = 100;
  if (LCP > 2500) cwv -= 30;
  if (INP > 200)  cwv -= 30;
  if (CLS > 0.1)  cwv -= 40;
  cwv = Math.max(0, cwv);

  // Checklists
  const onPageTotal = 7;
  let onPagePassed = 0;
  const on = extra.onPage;
  if (on.title && on.title.length <= 60) onPagePassed++;
  if (on.metaDesc && on.metaDesc.length <= 160) onPagePassed++;
  if (on.h1Count === 1) onPagePassed++;
  if (on.og) onPagePassed++;
  if (on.twitter) onPagePassed++;
  if (on.viewport) onPagePassed++;
  if (on.altPct >= 80) onPagePassed++;

  const techTotal = 4;
  let techPassed = 0;
  if (extra.directives.robots) techPassed++;
  if (extra.directives.sitemap) techPassed++;
  // naive canonical/https signals via LH audits if available
  if (perf > 0) techPassed++;
  if (seo  > 0) techPassed++;

  const eeatTotal = 3;
  let eeatPassed = 0;
  if (extra.eeat.hasAuthor) eeatPassed++;
  if (extra.eeat.hasAbout) eeatPassed++;
  if (extra.eeat.hasContact) eeatPassed++;

  const overall =
    0.35*perf + 0.20*seo + 0.15*cwv +
    0.15*(onPagePassed/onPageTotal*100) +
    0.10*(techPassed/techTotal*100) +
    0.05*(eeatPassed/eeatTotal*100);

  // Build findings and pick top 3 by impact*confidence
  const findings = [];
  if (LCP > 2500) findings.push({ id:"cwv_lcp", impact:3, confidence:3, title:"Improve LCP (hero too heavy)", why:"Slow LCP hurts conversions & visibility.", how:"Compress hero to AVIF/WebP; preload; set width/height.", est_hours:1.5 });
  if (INP > 200)  findings.push({ id:"cwv_inp", impact:3, confidence:2, title:"Reduce INP (main-thread busy)", why:"Poor interactivity hurts UX.", how:"Code-split; defer non-critical JS; remove heavy libs.", est_hours:2 });
  if (CLS > 0.1)  findings.push({ id:"cwv_cls", impact:3, confidence:3, title:"Fix layout shift (CLS)", why:"Layout jumps frustrate users.", how:"Reserve space for images/ads; set dimensions.", est_hours:0.8 });
  if (!on.metaDesc) findings.push({ id:"meta_description", impact:2, confidence:3, title:"Add meta description", why:"Boost SERP CTR.", how:"Write 140–160 chars incl. primary intent + CTA.", est_hours:0.3 });
  if (on.h1Count !== 1) findings.push({ id:"h1_count", impact:2, confidence:2, title:"Ensure exactly one H1", why:"Clear topical focus.", how:"One H1; use H2/H3 for structure.", est_hours:0.3 });
  if (extra.eeat.hasAbout === false) findings.push({ id:"about_page", impact:1, confidence:2, title:"Add/About page", why:"Trust/E-E-A-T signal.", how:"Publish About with credentials & address.", est_hours:0.5 });
  if (extra.local.napText === false) findings.push({ id:"local_nap", impact:2, confidence:2, title:"Add NAP", why:"Local relevance.", how:"Place Name/Address/Phone in footer & schema.", est_hours:0.5 });

  const topFixes = findings
    .map(f => ({ ...f, score: f.impact * f.confidence }))
    .sort((a,b) => b.score - a.score)
    .slice(0,3);

  return {
    topFixes,
    scores: {
      overall: Math.round(overall),
      lighthouse: { performance: perf, seo, bestPractices: bp, accessibility: acc },
      coreWebVitals: { lcp_ms: Math.round(LCP), inp_ms: Math.round(INP), cls: CLS, passed: (LCP<=2500 && INP<=200 && CLS<=0.1) },
      checklists: {
        onPage_passed: onPagePassed, onPage_total: onPageTotal,
        tech_passed: techPassed, tech_total: techTotal,
        eeat_passed: eeatPassed, eeat_total: eeatTotal
      }
    }
  };
}
--------------------------------

lib/render.mjs
--------------------------------
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";
import puppeteer from "puppeteer";
import { minify } from "html-minifier-terser";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export async function renderAndSave({ id, url, lh, extra, scored, brand, baseUrl }) {
  const outDir = path.join(__dirname, "..", "reports", id);
  await fs.mkdir(outDir, { recursive: true });

  const tpl = await fs.readFile(path.join(__dirname, "..", "templates", "report.html"), "utf8");
  const htmlRaw = tpl
    .replaceAll("{{BRAND}}", brand)
    .replaceAll("{{URL}}", url)
    .replaceAll("{{SCORE}}", String(scored.scores.overall))
    .replaceAll("{{TOPFIXES_JSON}}", JSON.stringify(scored.topFixes, null, 2))
    .replaceAll("{{SCORES_JSON}}", JSON.stringify(scored.scores, null, 2));
  const html = await minify(htmlRaw, { collapseWhitespace: true, minifyCSS: true, minifyJS: true });

  const htmlPath = path.join(outDir, "report.html");
  await fs.writeFile(htmlPath, html, "utf8");

  const browser = await puppeteer.launch({ args: ["--no-sandbox"] });
  const page = await browser.newPage();
  await page.setContent(html, { waitUntil: "networkidle0" });
  const pdfPath = path.join(outDir, "report.pdf");
  await page.pdf({ path: pdfPath, format: "A4", printBackground: true });
  const pngPath = path.join(outDir, "mobile.png");
  await page.screenshot({ path: pngPath, fullPage: true });
  await browser.close();

  const base = process.env.BASE_URL?.replace(/\/$/, "") || "";
  return {
    reportHtmlUrl: `${base}/reports/${id}/report.html`,
    reportPdfUrl: `${base}/reports/${id}/report.pdf`,
    screenshotUrl: `${base}/reports/${id}/mobile.png`,
    finalUrl: url
  };
}
--------------------------------

lib/webhook.mjs
--------------------------------
export async function sendToGHL(payload) {
  const url = process.env.GHL_WEBHOOK_URL;
  if (!url) return;
  await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
}
--------------------------------

templates/report.html (minimal)
--------------------------------
<!doctype html><html lang="en"><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>{{BRAND}} Audit</title>
<style>
 body{font-family:system-ui,-apple-system,Segoe UI,Roboto; margin:24px; color:#111}
 .score{font-size:48px;font-weight:800}
 .fix{margin:8px 0;padding:8px;border:1px solid #eee;border-radius:10px}
 pre{white-space:pre-wrap;word-wrap:break-word;background:#fafafa;padding:12px;border-radius:8px}
</style>
</head><body>
<h1>{{BRAND}} — Site Audit</h1>
<p><strong>URL:</strong> {{URL}}</p>
<p class="score">Overall Score: {{SCORE}}</p>

<h2>Top 3 Critical Fixes</h2>
<div id="fixes"></div>

<h2>Scores</h2>
<pre id="scores"></pre>

<script>
 const fixes = {{TOPFIXES_JSON}};
 const scores = {{SCORES_JSON}};
 const fixesEl = document.getElementById('fixes');
 fixes.forEach(f=>{
   const el = document.createElement('div');
   el.className='fix';
   el.innerHTML = `<strong>${f.title}</strong><br><em>${f.why}</em><br>How: ${f.how}<br>Est: ${f.est_hours} h`;
   fixesEl.appendChild(el);
 });
 document.getElementById('scores').textContent = JSON.stringify(scores,null,2);
</script>
</body></html>
--------------------------------

Deliverables
- Live API at: https://sitesurgeon-api.replit.app
- Test:
  curl -X POST https://sitesurgeon-api.replit.app/api/audit \
    -H "content-type: application/json" \
    -d '{"url":"https://example.com","email":"owner@example.com","name":"Example"}'
- Return the JSON + open report.html to confirm branding and fixes.
- Confirm GHL webhook received with report links and fields.

Notes
- Use Lighthouse first; PSI API is optional fallback if Chrome can’t launch.
- Keep everything lean; no auth for MVP, but include basic rate limit.
- Timezone: assume ET for any timestamps in emails.
